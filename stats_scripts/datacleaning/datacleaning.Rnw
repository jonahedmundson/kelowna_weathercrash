\documentclass[11pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry} %Sets proper 1-inch margins. 
\usepackage{amsmath} %Only load this if you are using math/equations.
\usepackage{graphicx} %Only need to call this if inserting images.
\usepackage{caption} %Only need to call this if inserting captions.
\usepackage{float} %Allows the use of the [H] specifier. 
\graphicspath{{C:/Users/jonah/Pictures/meme/}} %Sets the working directory for images.
\usepackage[colorlinks,citecolor=blue,linkcolor=blue,urlcolor=blue]{hyperref} %Allows for the embedding of urls. 
\usepackage{setspace}
\usepackage{blindtext}

\pagenumbering{arabic}

\usepackage{fancyhdr}

\pagestyle{fancy}
\fancyhf{}
\rhead{Jonah Edmundson \\ Jan 2023}
\lhead{\thepage}

\newcommand{\comment}[1]{}

\begin{document}
\SweaveOpts{concordance=TRUE}

\begin{center}
\Large{\textsc{Data Cleaning}}
\par
\normalsize{\textsc{for the}}
\par
\large{\textsc{Kelowna Weather-Crash Project}}
\end{center}


\vspace{0.917 pc} %Creates a paragraph line break. 

\tableofcontents


\pagebreak
\section{Introduction}



group weather data based on time groups in crash dataset, then join weather data on crash table (1 case = 1 crash, what was the weather like when this crash occurred?)




\pagebreak
\section{Weather Data}
Loading in weather data:

<<chunk1, echo=TRUE>>=
fullWeather = c()
for (i in c(2017:2021)){
  for (j in c(1:12)){
    temp = subset(read.csv(paste0('../../weatherdata/en_climate_hourly_BC_1123939_', 
      sprintf("%02d", j), '-', i, '_P1H.csv')), 
      select = - c(`Temp.Flag`, 
      `Dew.Point.Temp.Flag`, `Rel.Hum.Flag`,
      `Precip..Amount.Flag`, `Wind.Dir.Flag`, 
      `Wind.Spd.Flag`, `Visibility.Flag`, 
      `Stn.Press.Flag`, `Hmdx`, `Hmdx.Flag`, `Wind.Chill.Flag`))
    fullWeather = rbind(fullWeather, temp)
  }
}
  
nrow(fullWeather)
24*365*5 + 24 #2020 was a leap year

#assigning a Julian day variable
library(lubridate)
fullWeather$julianday = yday(as.Date(fullWeather$Date.Time..LST., tz='LST'))

summary(fullWeather)
@

\pagebreak

There are 22 empty strings in the \texttt{Weather} variable that should be NAs.

<<chunk2, echo=TRUE>>=
length(fullWeather[fullWeather$Weather == "" &
              is.na(fullWeather$Weather) == FALSE, "Weather"])

## SETTING EMPTY TO NA
fullWeather$Weather[fullWeather$Weather == "" &
              is.na(fullWeather$Weather) == FALSE] = NA

## CHECKING
length(fullWeather[fullWeather$Weather == "" &
              is.na(fullWeather$Weather) == FALSE, "Weather"])
@

Need to relevel factor to remove empty string option:

<<chunk3, echo=TRUE>>=
"" %in% levels(fullWeather$Weather)
fullWeather$Weather = droplevels(fullWeather$Weather)
"" %in% levels(fullWeather$Weather)
@

\pagebreak

Changing \texttt{Weather} factor variable to many indicator variables. 

<<chunk5>>=
#creating columns
lst = c()
for (i in levels(fullWeather$Weather)){
  temp = unlist(strsplit(as.character(i), ","))
  lst = c(lst, temp)
}
lst = lst[!(duplicated(lst))] #removing duplicates
lst

for (i in lst){
  fullWeather[, i] = factor("0", levels = c("0", "1"))
}

names(fullWeather)

############

#assigning values
for (i in 1:nrow(fullWeather)){
  if (!is.na(fullWeather$Weather[i])){
    temp = as.character(fullWeather$Weather[i])
    temp = unlist(strsplit(temp, ","))
    for (j in temp){
      fullWeather[i, j] = "1"
    }
  }
}

###########

#collapsing to only: Rain, Snow, Thunderstorms, Fog, Freezing Rain
fullWeather$Rain[fullWeather$'Moderate Rain' == 1] = 1
fullWeather$Rain[fullWeather$'Heavy Rain' == 1] = 1
fullWeather$Snow[fullWeather$'Moderate Snow' == 1] = 1
fullWeather$Snow[fullWeather$'Heavy Snow' == 1] = 1
fullWeather$Snow[fullWeather$'Blowing Snow' == 1] = 1
fullWeather$Fog[fullWeather$'Freezing Fog' == 1] = 1
fullWeather$Fog[fullWeather$'Haze' == 1] = 1

fullWeather = subset(fullWeather, select = - c(`Moderate Rain`, 
              `Heavy Rain`, `Moderate Snow`, `Heavy Snow`, 
              `Blowing Snow`, `Freezing Fog`, `Haze`))

summary(fullWeather[,c("Weather", "Rain", "Fog", "Snow", 
                       "Thunderstorms", "Freezing Rain")])
@

I realize that I could have used a regex solution here to shorten the code, but the solution above is more general. This is important if I wanted to add/remove groups to/from the reduced list of weather types later on (ie. adding `Heavy Snow').
\par
*Note that I kept \texttt{Rain} and \texttt{Freezing Rain} separate and mutually exclusive. Therefore, if an hour had freezing rain, the indicator variables will have ``1" for \texttt{Freezing Rain}, and a ``0" for \texttt{Rain}.


\pagebreak

Testing if any hours have precipitation without the appropriate \texttt{Weather} variable:

<<chunk4a, echo=TRUE>>=
precip = which(fullWeather$Precip..Amount..mm. > 0 &
                    is.na(fullWeather$Precip..Amount..mm.) == FALSE &
                    is.na(fullWeather$Weather)
) #gives rows that have precip but NA for weather
length(precip)
@

There are 356 cases where there is precipitation but no associated \texttt{Weather} variable!
\par
To fix this, we want to assign the appropriate \texttt{Weather} depending on the temperature. However, this is easier said than done. At what temperature does it snow versus rain?
\par
We can ask the data:

<<chunk4, echo=TRUE>>=
fullWeather$actual = NA
for (i in 1:nrow(fullWeather)){
  if (fullWeather$Rain[i] == 1){
    fullWeather$actual[i] = 'Rain'
  }
  if (fullWeather$Snow[i] == 1){
    fullWeather$actual[i] = 'Snow'
  }
}

assign = function(x){
  if (is.na(x)){
    return(NA)
  }
  if (x > 0){
    return("Above 0")
  } else {
    return("Below 0")
  }
}
#classification table
fullWeather$expected = sapply(fullWeather$Temp...C., assign)
rainsnow = table(fullWeather$expected, fullWeather$actual)
rainsnow

#probabilities
#chance of raining if above 0
rainprob = rainsnow[1,1]/(rainsnow[1,1]+rainsnow[1,2])
rainprob
#chance of snowing if below 0
snowprob = rainsnow[2,2]/(rainsnow[2,2]+rainsnow[2,1])
snowprob
@

In other words, whenever the temperature is above 0, it is usually raining (0.92\%). Similarly, whenever the temperature is below 0, it is basically always snowing (0.998\%).
\par
Therefore, we could assign our missing values based on these probabilities. However, it is intuitively true that as you get further from zero, these probabilities would change. Therefore, we can just use a random forest model to predict whether or not it will be snowing or raining based on the temperature:

<<chunk4RF, echo=TRUE, fig=TRUE>>=
training = subset(fullWeather[-precip,], 
                  subset = (is.na(fullWeather$actual[-precip]) == FALSE), 
                  select=c('Temp...C.', 'actual'))
training$actual = as.factor(training$actual)
library(randomForest)
RFmodel = randomForest(actual~Temp...C., data=training, importance=TRUE)
RFmodel
plot(training, col='red', main="Rain/Snow RF", yaxt='n', ylab="")
test = min(training$Temp...C.):max(training$Temp...C.)
lines(test, predict(RFmodel, 
                    data.frame(Temp...C. = test), type = "response"), lwd=2)
axis(side = 2, at = c(1,2), labels = c('Rain', 'Snow'), cex.axis=1.2, las=1)

#predicting missing (precip) values
rainsnowpredict = predict(RFmodel, 
                  fullWeather[precip,], type = "response")
#old Rain and Snow variables
summary(fullWeather$Rain)
summary(fullWeather$Snow)
#adding predictions
#where 0 = raining and 1 = snowing
for (i in names(rainsnowpredict)){
  if (rainsnowpredict[i] == 'Rain'){
    fullWeather[as.numeric(i), 'Rain'] = 1
    fullWeather[as.numeric(i), 'Weather'] = 'Rain'
  } else {
    fullWeather[as.numeric(i), 'Snow'] = 1
    fullWeather[as.numeric(i), 'Weather'] = 'Snow'
  }
}
#new Rain and Snow variables
summary(fullWeather$Rain)
summary(fullWeather$Snow)
#checking that it worked
length(which(fullWeather$Precip..Amount..mm. > 0 &
                    is.na(fullWeather$Precip..Amount..mm.) == FALSE &
                    is.na(fullWeather$Weather)))
@


<<chunk4glm, echo=FALSE, fig=TRUE, eval=FALSE>>=
training = subset(fullWeather[-precip,], 
                  subset = (is.na(fullWeather$actual[-precip]) == FALSE), 
                  select=c('Temp...C.', 'actual'))
training$actual = as.factor(training$actual)
rainsnow.glm = glm(actual~Temp...C., data = training, 
                   family = binomial)
#summary(rainsnow.glm)
plot(training, col='red', main="Rain/Snow GLM")
test = min(training$Temp...C.):max(training$Temp...C.)
lines(test, predict(rainsnow.glm, 
                    data.frame(Temp...C. = test), type = "response")+1, lwd=2)

#predicting missing (precip) values
rainsnowpredict = round(predict(rainsnow.glm, 
                  fullWeather[precip,], type = "response"))
#where 0 = raining and 1 = snowing
for (i in names(rainsnowpredict)){
  if (rainsnowpredict[i] == 0){
    fullWeather[as.numeric(i), 'Rain'] = 1
    fullWeather[as.numeric(i), 'Weather'] = 'Rain'
  } else {
    fullWeather[as.numeric(i), 'Snow'] = 1
    fullWeather[as.numeric(i), 'Weather'] = 'Snow'
  }
}
#new Rain and Snow variables
summary(fullWeather$Rain)
summary(fullWeather$Snow)
#checking that it worked
length(which(fullWeather$Precip..Amount..mm. > 0 &
                    is.na(fullWeather$Precip..Amount..mm.) == FALSE &
                    is.na(fullWeather$Weather)))
@



<<chunkwaste, eval=FALSE, fig=TRUE, echo=FALSE>>=
#temporal distribution of missing weather data
#table
table(month(as.Date(subset(fullWeather[precip,], subset = fullWeather$expected[precip] == 'Above 0' & (is.na(fullWeather$expected[precip]) == FALSE), select='Date.Time..LST.')$Date.Time..LST., tz='LST')))
table(month(as.Date(subset(fullWeather[precip,], subset = fullWeather$expected[precip] == 'Below 0' & (is.na(fullWeather$expected[precip]) == FALSE), select='Date.Time..LST.')$Date.Time..LST., tz='LST')))
#plot
plot(fullWeather$julianday[precip], as.factor(fullWeather$expected[precip]), 
     yaxt= 'n', ylim=c(0.5, 2.5), xlab='Julian Day', 
     ylab='Expected Weather (that is missing)', main='Temporal Distr. of Missing Weather Data')
axis(side = 2, at = c(1,2), labels = c('Missing Rain', 'Missing Snow'), cex.axis=0.8)
@



\pagebreak
\section{Crash Data}

Loading in crash data:

<<chunkX, echo=TRUE>>=
fullCrash = subset(read.csv('../../crashdata/Southern Interior_Full Data_data.csv'), 
          select = - c(`Crash.Breakdown.2`, `Region`,
                       `Municipality.Name..ifnull.`))
summary(fullCrash)
@

Now, while the crash data is overall much cleaner out-of-the-box than the weather data, the issue is that this crash dataset was made to be 4-anonymous, as the day of the month is not given. Instead, all we have is the month, year, and day of the week. This means we cannot perfectly know the weather on any given day. \par
A solution to this problem would be to randomly assign each of the 4 (or 5) possible weather conditions in each month to each of the corresponding possible days. A better alternative would be to average the weather conditions on each of the possible 4 days and then assign this same (averaged) weather condition to all 4 (or 5) days in that month. The precipitation type (rain, snow, fog, etc.) would then also be averaged (2 snows + 1 rain = snow) with a priority rating (1 snow + 1 rain = snow). 
\par
In order to do this, we will need to create a new column on which to join the two datasets. For the crash data, this is easy. 

<<chunknewcol, echo=TRUE>>=
fullCrash$linker = paste(fullCrash$Date.Of.Loss.Year,
                         fullCrash$Month.Of.Year, 
                         fullCrash$Day.Of.Week,
                         fullCrash$Time.Category)
head(fullCrash$linker)
@


For the weather data, we first collapse the hourly data to the same time periods as the crash data (00:00-02:59, 03:00-05:59, 06:00-08:59, 09:00-11:59, 12:00-14:59, 15:00-17:59, 18:00-20:59, 21:00-23:59):

<<chunkweathercollapse, echo=TRUE>>=

@



<<finalchunk, echo=TRUE>>=
#save(alldata, file = "../rda_files/all_data.rda")
@


\end{document}