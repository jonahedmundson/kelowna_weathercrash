\documentclass[11pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry} %Sets proper 1-inch margins. 
\usepackage{amsmath} %Only load this if you are using math/equations.
\usepackage{graphicx} %Only need to call this if inserting images.
\usepackage{caption} %Only need to call this if inserting captions.
\usepackage{float} %Allows the use of the [H] specifier. 
\graphicspath{{C:/Users/jonah/Pictures/meme/}} %Sets the working directory for images.
\usepackage[colorlinks,citecolor=blue,linkcolor=blue,urlcolor=blue]{hyperref} %Allows for the embedding of urls. 
\usepackage{setspace}
\usepackage{blindtext}

\pagenumbering{arabic}

\usepackage{fancyhdr}

\pagestyle{fancy}
\fancyhf{}
\rhead{Jonah Edmundson \\ Jan 2023}
\lhead{\thepage}

\newcommand{\comment}[1]{}

\begin{document}
\SweaveOpts{concordance=TRUE}

\begin{center}
\Large{\textsc{Data Cleaning}}
\par
\normalsize{\textsc{for}}
\par
\large{\textsc{Kelowna Weather-Crash Project}}
\end{center}


\vspace{0.917 pc} %Creates a paragraph line break. 

\section*{Section 1}


remove all 'flag' variables

group weather data based on time groups in crash dataset, then join weather data on crash table (1 case = 1 crash, what was the weather like when this crash occurred?)

is 'weather' reliable? may need to correct it if there is precipitation but NA for 'weather'

Loading in weather data:

<<chunk1, echo=TRUE>>=
fullWeather = c()
for (i in c(2017:2021)){
  for (j in c(1:12)){
    temp = subset(read.csv(paste0('../../weatherdata/en_climate_hourly_BC_1123939_', 
      sprintf("%02d", j), '-', i, '_P1H.csv')), 
      select = - c(`Temp.Flag`, 
      `Dew.Point.Temp.Flag`, `Rel.Hum.Flag`,
      `Precip..Amount.Flag`, `Wind.Dir.Flag`, 
      `Wind.Spd.Flag`, `Visibility.Flag`, 
      `Stn.Press.Flag`, `Hmdx`, `Hmdx.Flag`, `Wind.Chill.Flag`))
    fullWeather = rbind(fullWeather, temp)
  }
}
  
nrow(fullWeather)
24*365*5 + 24 #2020 was a leap year

#assigning a Julian day variable
library(lubridate)
fullWeather$julianday = yday(as.Date(fullWeather$Date.Time..LST., tz='LST'))

summary(fullWeather)
@

\pagebreak

There are 22 empty strings in the \texttt{Weather} variable that should be NAs.

<<chunk2, echo=TRUE>>=
length(fullWeather[fullWeather$Weather == "" &
              is.na(fullWeather$Weather) == FALSE, "Weather"])

## SETTING EMPTY TO NA
fullWeather$Weather[fullWeather$Weather == "" &
              is.na(fullWeather$Weather) == FALSE] = NA

## CHECKING
length(fullWeather[fullWeather$Weather == "" &
              is.na(fullWeather$Weather) == FALSE, "Weather"])
@

Need to relevel factor to remove empty string option:

<<chunk3, echo=TRUE>>=
"" %in% levels(fullWeather$Weather)
fullWeather$Weather = droplevels(fullWeather$Weather)
"" %in% levels(fullWeather$Weather)
@

\pagebreak

Changing \texttt{Weather} factor variable to many indicator variables. 

<<chunk5>>=
#creating columns
lst = c()
for (i in levels(fullWeather$Weather)){
  temp = unlist(strsplit(as.character(i), ","))
  lst = c(lst, temp)
}
lst = lst[!(duplicated(lst))] #removing duplicates
lst

for (i in lst){
  fullWeather[, i] = factor("0", levels = c("0", "1"))
}

names(fullWeather)

############

#assigning values
for (i in 1:nrow(fullWeather)){
  if (!is.na(fullWeather$Weather[i])){
    temp = as.character(fullWeather$Weather[i])
    temp = unlist(strsplit(temp, ","))
    for (j in temp){
      fullWeather[i, j] = "1"
    }
  }
}

###########

#collapsing to only: Rain, Snow, Thunderstorms, Fog, Freezing Rain
fullWeather$Rain[fullWeather$'Moderate Rain' == 1] = 1
fullWeather$Rain[fullWeather$'Heavy Rain' == 1] = 1
fullWeather$Snow[fullWeather$'Moderate Snow' == 1] = 1
fullWeather$Snow[fullWeather$'Heavy Snow' == 1] = 1
fullWeather$Snow[fullWeather$'Blowing Snow' == 1] = 1
fullWeather$Fog[fullWeather$'Freezing Fog' == 1] = 1
fullWeather$Fog[fullWeather$'Haze' == 1] = 1

fullWeather = subset(fullWeather, select = - c(`Moderate Rain`, 
              `Heavy Rain`, `Moderate Snow`, `Heavy Snow`, 
              `Blowing Snow`, `Freezing Fog`, `Haze`))

summary(fullWeather[,c("Weather", "Rain", "Fog", "Snow", 
                       "Thunderstorms", "Freezing Rain")])
@

I realize that I could have used a regex solution here to shorten the code, but the solution above is more general. This is important if I wanted to add/remove groups to/from the reduced list of weather types later on (ie. adding `Heavy Snow').
\par
*Note that I kept \texttt{Rain} and \texttt{Freezing Rain} separate and mutually exclusive. Therefore, if an hour had freezing rain, the indicator variables will have ``1" for \texttt{Freezing Rain}, and a ``0" for \texttt{Rain}.


\pagebreak

Testing if any hours have precipitation without the appropriate \texttt{Weather} variable:

<<chunk4a, echo=TRUE>>=
precip = which(fullWeather$Precip..Amount..mm. > 0 &
                    is.na(fullWeather$Precip..Amount..mm.) == FALSE &
                    is.na(fullWeather$Weather)
) #gives rows that have precip but NA for weather
length(precip)
@

There are 356 cases where there is precipitation but no associated \texttt{Weather} variable!
\par
To fix this, we want to assign the appropriate \texttt{Weather} depending on the temperature. However, this is easier said than done. At what temperature does it snow versus rain?
\par
We can ask the data:

<<chunk4, echo=TRUE>>=
fullWeather$actual = NA
for (i in 1:nrow(fullWeather)){
  if (fullWeather$Rain[i] == 1){
    fullWeather$actual[i] = 'Rain'
  }
  if (fullWeather$Snow[i] == 1){
    fullWeather$actual[i] = 'Snow'
  }
}

assign = function(x){
  if (is.na(x)){
    return(NA)
  }
  if (x > 0){
    return("Above 0")
  } else {
    return("Below 0")
  }
}
#classification table
fullWeather$expected = sapply(fullWeather$Temp...C., assign)
rainsnow = table(fullWeather$expected, fullWeather$actual)
rainsnow

#probabilities
#chance of raining if above 0
rainprob = rainsnow[1,1]/(rainsnow[1,1]+rainsnow[1,2])
rainprob
#chance of snowing if below 0
snowprob = rainsnow[2,2]/(rainsnow[2,2]+rainsnow[2,1])
snowprob
@

In other words, whenever the temperature is above 0, it is usually raining (0.92\%). Similarly, whenever the temperature is below 0, it is basically always snowing (0.998\%).
\par
Therefore, we could assign our missing values based on these probabilities. However, it is intuitively true that as you get further from zero, these probabilities would change. Therefore, we can just use a general linear model to predict whether or not it will be snowing or raining based on the temperature:

<<chunk4glm, echo=TRUE, fig=TRUE>>=
training = subset(fullWeather[-precip,], 
                  subset = (is.na(fullWeather$actual[-precip]) == FALSE), 
                  select=c('Temp...C.', 'actual'))
training$actual = as.factor(training$actual)
rainsnow.glm = glm(actual~Temp...C., data = training, 
                   family = binomial)
#summary(rainsnow.glm)
plot(training, col='red', main="Rain/Snow GLM")
test = min(training$Temp...C.):max(training$Temp...C.)
lines(test, predict(rainsnow.glm, 
                    data.frame(Temp...C. = test), type = "response")+1, lwd=2)

#predicting missing (precip) values
rainsnowpredict = round(predict(rainsnow.glm, 
                  fullWeather[precip,], type = "response"))
#where 0 = raining and 1 = snowing
for (i in names(rainsnowpredict)){
  if (rainsnowpredict[i] == 0){
    fullWeather[as.numeric(i), 'Rain'] = 1
    fullWeather[as.numeric(i), 'Weather'] = 'Rain'
  } else {
    fullWeather[as.numeric(i), 'Snow'] = 1
    fullWeather[as.numeric(i), 'Weather'] = 'Snow'
  }
}
#new Rain and Snow variables
summary(fullWeather$Rain)
summary(fullWeather$Snow)
#checking that it worked
length(which(fullWeather$Precip..Amount..mm. > 0 &
                    is.na(fullWeather$Precip..Amount..mm.) == FALSE &
                    is.na(fullWeather$Weather)))
@



<<chunkwaste, eval=FALSE, fig=TRUE, echo=FALSE>>=
#temporal distribution of missing weather data
#table
table(month(as.Date(subset(fullWeather[precip,], subset = fullWeather$expected[precip] == 'Above 0' & (is.na(fullWeather$expected[precip]) == FALSE), select='Date.Time..LST.')$Date.Time..LST., tz='LST')))
table(month(as.Date(subset(fullWeather[precip,], subset = fullWeather$expected[precip] == 'Below 0' & (is.na(fullWeather$expected[precip]) == FALSE), select='Date.Time..LST.')$Date.Time..LST., tz='LST')))
#plot
plot(fullWeather$julianday[precip], as.factor(fullWeather$expected[precip]), 
     yaxt= 'n', ylim=c(0.5, 2.5), xlab='Julian Day', 
     ylab='Expected Weather (that is missing)', main='Temporal Distr. of Missing Weather Data')
axis(side = 2, at = c(1,2), labels = c('Missing Rain', 'Missing Snow'), cex.axis=0.8)
@



\pagebreak

Loading in crash data:

<<chunkX, echo=TRUE>>=
fullCrash = subset(read.csv('../../crashdata/Southern Interior_Full Data_data.csv'), 
          select = - c(`Crash.Breakdown.2`, `Region`,
                       `Municipality.Name..ifnull.`))
summary(fullCrash)
@




<<finalchunk, echo=TRUE>>=
#save(alldata, file = "../rda_files/all_data.rda")
@


\end{document}