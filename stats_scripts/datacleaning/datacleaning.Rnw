\documentclass[11pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry} %Sets proper 1-inch margins. 
\usepackage{amsmath} %Only load this if you are using math/equations.
\usepackage{graphicx} %Only need to call this if inserting images.
\usepackage{caption} %Only need to call this if inserting captions.
\usepackage{float} %Allows the use of the [H] specifier. 
\usepackage[colorlinks,citecolor=blue,linkcolor=blue,urlcolor=blue]{hyperref} %Allows for the embedding of urls. 
\usepackage{setspace}
\usepackage{blindtext}

\pagenumbering{arabic}

\usepackage{fancyhdr}

\pagestyle{fancy}
\fancyhf{}
\rhead{Jonah Edmundson \\ Jan 2023}
\lhead{\thepage}

\newcommand{\comment}[1]{}

\begin{document}
\SweaveOpts{concordance=TRUE}

\begin{center}
\Large{\textsc{Data Cleaning}}
\par
\normalsize{\textsc{for the}}
\par
\large{\textsc{Kelowna Weather-Crash Project}}
\end{center}


\vspace{0.917 pc} %Creates a paragraph line break. 

\tableofcontents


\pagebreak
\section{Introduction}



Here I present the data cleaning for each dataset, as well as the process of combining the datasets. 




\pagebreak
\section{Weather Data}
Loading in weather data:

<<chunk1, echo=TRUE>>=
fullWeather = c()
for (i in c(2017:2021)){
  for (j in c(1:12)){
    temp = subset(read.csv(paste0('../../weatherdata/en_climate_hourly_BC_1123939_', 
      sprintf("%02d", j), '-', i, '_P1H.csv')), 
      select = - c(`Temp.Flag`, 
      `Dew.Point.Temp.Flag`, `Rel.Hum.Flag`,
      `Precip..Amount.Flag`, `Wind.Dir.Flag`, 
      `Wind.Spd.Flag`, `Visibility.Flag`, 
      `Stn.Press.Flag`, `Hmdx`, `Hmdx.Flag`, `Wind.Chill.Flag`))
    fullWeather = rbind(fullWeather, temp)
  }
}
  
nrow(fullWeather)
24*365*5 + 24 #2020 was a leap year

#assigning a Julian day variable
library(lubridate)
fullWeather$julianday = yday(as.Date(fullWeather$Date.Time..LST., tz='LST'))

summary(fullWeather)
@

\pagebreak

There are 22 empty strings in the \texttt{Weather} variable that should be NAs.

<<chunk2, echo=TRUE>>=
length(fullWeather[fullWeather$Weather == "" &
              is.na(fullWeather$Weather) == FALSE, "Weather"])

## SETTING EMPTY TO NA
fullWeather$Weather[fullWeather$Weather == "" &
              is.na(fullWeather$Weather) == FALSE] = NA

## CHECKING
length(fullWeather[fullWeather$Weather == "" &
              is.na(fullWeather$Weather) == FALSE, "Weather"])
@

Need to relevel factor to remove empty string option:

<<chunk3, echo=TRUE>>=
"" %in% levels(fullWeather$Weather)
fullWeather$Weather = droplevels(fullWeather$Weather)
"" %in% levels(fullWeather$Weather)
@

\pagebreak

Changing \texttt{Weather} factor variable to many indicator variables. 

<<chunk5>>=
#creating columns
lst = c()
for (i in levels(fullWeather$Weather)){
  temp = unlist(strsplit(as.character(i), ","))
  lst = c(lst, temp)
}
lst = lst[!(duplicated(lst))] #removing duplicates
lst

for (i in lst){
  fullWeather[, i] = factor("0", levels = c("0", "1"))
}

names(fullWeather)

############

#assigning values
for (i in 1:nrow(fullWeather)){
  if (!is.na(fullWeather$Weather[i])){
    temp = as.character(fullWeather$Weather[i])
    temp = unlist(strsplit(temp, ","))
    for (j in temp){
      fullWeather[i, j] = "1"
    }
  }
}

###########

#collapsing to only: Rain, Snow, Thunderstorms, Fog, Freezing Rain
fullWeather$Rain[fullWeather$'Moderate Rain' == 1] = 1
fullWeather$Rain[fullWeather$'Heavy Rain' == 1] = 1
fullWeather$Snow[fullWeather$'Moderate Snow' == 1] = 1
fullWeather$Snow[fullWeather$'Heavy Snow' == 1] = 1
fullWeather$Snow[fullWeather$'Blowing Snow' == 1] = 1
fullWeather$Fog[fullWeather$'Freezing Fog' == 1] = 1
fullWeather$Fog[fullWeather$'Haze' == 1] = 1

fullWeather = subset(fullWeather, select = - c(`Moderate Rain`, 
              `Heavy Rain`, `Moderate Snow`, `Heavy Snow`, 
              `Blowing Snow`, `Freezing Fog`, `Haze`))

summary(fullWeather[,c("Weather", "Rain", "Fog", "Snow", 
                       "Thunderstorms", "Freezing Rain")])

#converting indicator columns to numeric
fullWeather$Fog = as.numeric(as.character(fullWeather$Fog))
fullWeather$'Freezing Rain' = as.numeric(as.character(fullWeather$'Freezing Rain'))
fullWeather$Snow = as.numeric(as.character(fullWeather$Snow))
fullWeather$Rain = as.numeric(as.character(fullWeather$Rain))
fullWeather$Thunderstorms = as.numeric(as.character(fullWeather$Thunderstorms))
@

I realize that I could have used a regex solution here to shorten the code, but the solution above is more general. This is important if I wanted to add/remove groups to/from the reduced list of weather types later on (ie. adding `Heavy Snow').
\par
*Note that I kept \texttt{Rain} and \texttt{Freezing Rain} separate and mutually exclusive. Therefore, if an hour had freezing rain, the indicator variables will have ``1" for \texttt{Freezing Rain}, and a ``0" for \texttt{Rain}.


\pagebreak

Testing if any hours have precipitation without the appropriate \texttt{Weather} variable:

<<chunk4a, echo=TRUE>>=
precip = which(fullWeather$Precip..Amount..mm. > 0 &
                    is.na(fullWeather$Precip..Amount..mm.) == FALSE &
                    is.na(fullWeather$Weather)
) #gives rows that have precip but NA for weather
length(precip)
@

There are 356 cases where there is precipitation but no associated \texttt{Weather} variable!
\par
To fix this, we want to assign the appropriate \texttt{Weather} depending on the temperature. However, this is easier said than done. At what temperature does it snow versus rain?
\par
We can ask the data:

<<chunk4, echo=TRUE>>=
fullWeather$actual = NA
for (i in 1:nrow(fullWeather)){
  if (fullWeather$Rain[i] == 1){
    fullWeather$actual[i] = 'Rain'
  }
  if (fullWeather$Snow[i] == 1){
    fullWeather$actual[i] = 'Snow'
  }
}

assign = function(x){
  if (is.na(x)){
    return(NA)
  }
  if (x > 0){
    return("Above 0")
  } else {
    return("Below 0")
  }
}
#classification table
fullWeather$expected = sapply(fullWeather$Temp...C., assign)
rainsnow = table(fullWeather$expected, fullWeather$actual)
rainsnow

#probabilities
#chance of raining if above 0
rainprob = rainsnow[1,1]/(rainsnow[1,1]+rainsnow[1,2])
rainprob
#chance of snowing if below 0
snowprob = rainsnow[2,2]/(rainsnow[2,2]+rainsnow[2,1])
snowprob
@

In other words, whenever the temperature is above 0, it is usually raining (92\%). Similarly, whenever the temperature is below 0, it is basically always snowing (99.8\%).
\par
Therefore, we could assign our missing values based on these probabilities. However, it is intuitively true that as you get further from zero, these probabilities would change. Therefore, we can just use a random forest model to predict whether or not it will be snowing or raining based on the temperature:

<<chunk4RF, echo=TRUE, fig=TRUE>>=
training = subset(fullWeather[-precip,], 
                  subset = (is.na(fullWeather$actual[-precip]) == FALSE), 
                  select=c('Temp...C.', 'actual'))
training$actual = as.factor(training$actual)
library(randomForest)
RFmodel = randomForest(actual~Temp...C., data=training, importance=TRUE)
RFmodel
plot(training, col='red', main="Rain/Snow RF", yaxt='n', ylab="")
test = min(training$Temp...C.):max(training$Temp...C.)
lines(test, predict(RFmodel, 
                    data.frame(Temp...C. = test), type = "response"), lwd=2)
axis(side = 2, at = c(1,2), labels = c('Rain', 'Snow'), cex.axis=1.2, las=1)

#predicting missing (precip) values
rainsnowpredict = predict(RFmodel, 
                  fullWeather[precip,], type = "response")
#old Rain and Snow variables
summary(as.factor(fullWeather$Rain))
summary(as.factor(fullWeather$Snow))
#adding predictions
#where 0 = raining and 1 = snowing
for (i in names(rainsnowpredict)){
  if (rainsnowpredict[i] == 'Rain'){
    fullWeather[as.numeric(i), 'Rain'] = 1
    fullWeather[as.numeric(i), 'Weather'] = 'Rain'
  } else {
    fullWeather[as.numeric(i), 'Snow'] = 1
    fullWeather[as.numeric(i), 'Weather'] = 'Snow'
  }
}
#new Rain and Snow variables
summary(as.factor(fullWeather$Rain))
summary(as.factor(fullWeather$Snow))
#checking that it worked
length(which(fullWeather$Precip..Amount..mm. > 0 &
                    is.na(fullWeather$Precip..Amount..mm.) == FALSE &
                    is.na(fullWeather$Weather)))
@


<<chunk4glm, echo=FALSE, fig=TRUE, eval=FALSE>>=
training = subset(fullWeather[-precip,], 
                  subset = (is.na(fullWeather$actual[-precip]) == FALSE), 
                  select=c('Temp...C.', 'actual'))
training$actual = as.factor(training$actual)
rainsnow.glm = glm(actual~Temp...C., data = training, 
                   family = binomial)
#summary(rainsnow.glm)
plot(training, col='red', main="Rain/Snow GLM")
test = min(training$Temp...C.):max(training$Temp...C.)
lines(test, predict(rainsnow.glm, 
                    data.frame(Temp...C. = test), type = "response")+1, lwd=2)

#predicting missing (precip) values
rainsnowpredict = round(predict(rainsnow.glm, 
                  fullWeather[precip,], type = "response"))
#where 0 = raining and 1 = snowing
for (i in names(rainsnowpredict)){
  if (rainsnowpredict[i] == 0){
    fullWeather[as.numeric(i), 'Rain'] = 1
    fullWeather[as.numeric(i), 'Weather'] = 'Rain'
  } else {
    fullWeather[as.numeric(i), 'Snow'] = 1
    fullWeather[as.numeric(i), 'Weather'] = 'Snow'
  }
}
#new Rain and Snow variables
summary(as.factor(fullWeather$Rain))
summary(as.factor(fullWeather$Snow))
#checking that it worked
length(which(fullWeather$Precip..Amount..mm. > 0 &
                    is.na(fullWeather$Precip..Amount..mm.) == FALSE &
                    is.na(fullWeather$Weather)))
@



<<chunkwaste, eval=FALSE, fig=TRUE, echo=FALSE>>=
#temporal distribution of missing weather data
#table
table(month(as.Date(subset(fullWeather[precip,], subset = fullWeather$expected[precip] == 'Above 0' & (is.na(fullWeather$expected[precip]) == FALSE), select='Date.Time..LST.')$Date.Time..LST., tz='LST')))
table(month(as.Date(subset(fullWeather[precip,], subset = fullWeather$expected[precip] == 'Below 0' & (is.na(fullWeather$expected[precip]) == FALSE), select='Date.Time..LST.')$Date.Time..LST., tz='LST')))
#plot
plot(fullWeather$julianday[precip], as.factor(fullWeather$expected[precip]), 
     yaxt= 'n', ylim=c(0.5, 2.5), xlab='Julian Day', 
     ylab='Expected Weather (that is missing)', main='Temporal Distr. of Missing Weather Data')
axis(side = 2, at = c(1,2), labels = c('Missing Rain', 'Missing Snow'), cex.axis=0.8)
@



\pagebreak
\section{Crash Data}

Loading in crash data:

<<chunkX, echo=TRUE>>=
fullCrash = subset(read.csv('../../crashdata/Southern Interior_Full Data_data.csv'), 
          select = - c(`Crash.Breakdown.2`, `Region`,
                       `Municipality.Name..ifnull.`))
summary(fullCrash)
@

Now, while the crash data is overall much cleaner out-of-the-box than the weather data, the issue is that this crash dataset was made to be 4-anonymous, as the day of the month is not given. Instead, all we have is the month, year, and day of the week. This means we cannot perfectly know the weather on any given day. This massively reduces the power of any statistical tests that we perform with the data, but without being able to reidentify any of the observations, this is the best that we can do. 
\par
A solution to this problem would be to randomly assign each of the 4 (or 5) possible weather conditions in each month to each of the corresponding possible days. A better alternative would be to average the weather conditions on each of the possible 4 days and then assign this same (averaged) weather condition to all 4 (or 5) days in that month. The precipitation type (rain, snow, fog, etc.) would then also be averaged (2 snows + 1 rain = snow) with a priority rating (1 snow + 1 rain = snow). 
\par
In order to do this, we will need to create a new column on which to join the two datasets. For the crash data, this is easy. 

<<chunknewcol, echo=TRUE>>=
fullCrash$linker = paste(fullCrash$Date.Of.Loss.Year,
                         fullCrash$Month.Of.Year, 
                         fullCrash$Day.Of.Week,
                         fullCrash$Time.Category)
head(fullCrash$linker)
@


For the weather data, we first collapse the hourly data to the same time periods as the crash data (00:00-02:59, 03:00-05:59, 06:00-08:59, 09:00-11:59, 12:00-14:59, 15:00-17:59, 18:00-20:59, 21:00-23:59):

<<chunkweathercollapse, echo=TRUE>>=
weatherTime = function(x){ 
  #assigns the correct time category
  if (x %in% c('00:00', '01:00', '02:00')){
    return('00:00-02:59')
  }
  if (x %in% c('03:00', '04:00', '05:00')){
    return('03:00-05:59')
  }
  if (x %in% c('06:00', '07:00', '08:00')){
    return('06:00-08:59')
  }
  if (x %in% c('09:00', '10:00', '11:00')){
    return('09:00-11:59')
  }
  if (x %in% c('12:00', '13:00', '14:00')){
    return('12:00-14:59')
  }
  if (x %in% c('15:00', '16:00', '17:00')){
    return('15:00-17:59')
  }
  if (x %in% c('18:00', '19:00', '20:00')){
    return('18:00-20:59')
  }
  if (x %in% c('21:00', '22:00', '23:00')){
    return('21:00-23:59')
  }
}

fullWeather$timeCategory = sapply(fullWeather$Time..LST., weatherTime)
@


Next, we need to get the day of the week. Then we can create the linker for the weather data:

<<chunkweatherdayoftheweek, echo=TRUE>>=
#weekday, in uppercase
fullWeather$weekday = toupper(as.character(wday(as.Date(fullWeather$Date.Time..LST., tz='LST'), label=TRUE, abbr=FALSE)))

#month
fullWeather$monthName = toupper(as.character(month(as.Date(fullWeather$Date.Time..LST., tz='LST'), label=TRUE, abbr=FALSE)))

#creating weather linker column
fullWeather$linker = paste(fullWeather$Year,
                         fullWeather$monthName,
                         fullWeather$weekday,
                         fullWeather$timeCategory)
head(fullWeather$linker)

#we now can average the weather over these time periods
timereducedWeather = c()
j = 1
for (i in seq(1, nrow(fullWeather), 3)){
  #creating a whole new dataframe
  timereducedWeather$linker[j] = fullWeather$linker[i]
  #avg of temp
  timereducedWeather$Temp...C.[j] = mean(c(fullWeather$Temp...C.[i],
    fullWeather$Temp...C.[i+1], fullWeather$Temp...C.[i+2]), na.rm = TRUE)
  #avg of dew point temp
  timereducedWeather$Dew.Point.Temp...C.[j] = mean(c(fullWeather$Dew.Point.Temp...C.[i],
    fullWeather$Dew.Point.Temp...C.[i+1], fullWeather$Dew.Point.Temp...C.[i+2]), na.rm = TRUE)
  #avg of relative humidity
  timereducedWeather$Rel.Hum....[j] = mean(c(fullWeather$Rel.Hum....[i],
    fullWeather$Rel.Hum....[i+1], fullWeather$Rel.Hum....[i+2]), na.rm = TRUE)
  #avg of precipitation amount
  timereducedWeather$Precip..Amount..mm.[j] = mean(c(fullWeather$Precip..Amount..mm.[i],
    fullWeather$Precip..Amount..mm.[i+1], fullWeather$Precip..Amount..mm.[i+2]), na.rm = TRUE)
  #avg of wind direction
  timereducedWeather$Wind.Dir..10s.deg.[j] = mean(c(fullWeather$Wind.Dir..10s.deg.[i],
    fullWeather$Wind.Dir..10s.deg.[i+1], fullWeather$Wind.Dir..10s.deg.[i+2]), na.rm = TRUE)
  #avg of wind speed
  timereducedWeather$Wind.Spd..km.h.[j] = mean(c(fullWeather$Wind.Spd..km.h.[i], 
    fullWeather$Wind.Spd..km.h.[i+1],  fullWeather$Wind.Spd..km.h.[i+2]), na.rm = TRUE)
  #avg of visibility
  timereducedWeather$Visibility..km.[j] = mean(c(fullWeather$Visibility..km.[i],
    fullWeather$Visibility..km.[i+1], fullWeather$Visibility..km.[i+2]), na.rm = TRUE)
  #avg of stn pressure
  timereducedWeather$Stn.Press..kPa.[j] = mean(c(fullWeather$Stn.Press..kPa.[i],
    fullWeather$Stn.Press..kPa.[i+1], fullWeather$Stn.Press..kPa.[i+2]), na.rm = TRUE)
  #avg of wind chill
  timereducedWeather$Wind.Chill[j] = mean(c(fullWeather$Wind.Chill[i],
    fullWeather$Wind.Chill[i+1], fullWeather$Wind.Chill[i+2]), na.rm = TRUE)
  #indicator variables
  timereducedWeather$Fog[j] = max(c(fullWeather$Fog[i], fullWeather$Fog[i+1], 
                            fullWeather$Fog[i+2]))
  timereducedWeather$'Freezing Rain'[j] = max(c(fullWeather$'Freezing Rain'[i], 
        fullWeather$'Freezing Rain'[i+1], fullWeather$'Freezing Rain'[i+2]))
  timereducedWeather$Snow[j] = max(c(fullWeather$Snow[i], fullWeather$Snow[i+1], 
                            fullWeather$Snow[i+2]))
  timereducedWeather$Rain[j] = max(c(fullWeather$Rain[i], fullWeather$Rain[i+1], 
                            fullWeather$Rain[i+2]))
  timereducedWeather$Thunderstorms[j] = max(c(fullWeather$Thunderstorms[i], 
        fullWeather$Thunderstorms[i+1], fullWeather$Thunderstorms[i+2]))
  #incrementing ticker
  j = j+1
}
timereducedWeather = as.data.frame(timereducedWeather)
head(timereducedWeather)
@

Now, it is important to re-focus on what we want to do. We want to know the weather that was occurring during each crash (ie. for each row in the crash dataset). The only thing preventing us from doing this is that for each unique linker in the crash data, there are 4 (or 5) equivalent linkers in the weather dataset. In order to remove this ambiguity, we need to average the weather over the weather rows that have identical linkers. 

<<weatheraverage, echo=TRUE>>=
#proof of principle (shows number of times each unique linker occurs)
table(table(timereducedWeather$linker)) 

#getting indices of duplicates
idx = duplicated(timereducedWeather$linker)
finalWeather = timereducedWeather[!idx,]
@

Now, the final step. We need to join the crash and weather datasets.

<<secondlast, echo=TRUE>>=
alldata = merge(x=fullCrash,y=finalWeather,by="linker",all.x=TRUE, sort=FALSE)
head(alldata)
@




Saving the cleaned dataset:

<<finalchunk, echo=TRUE>>=
#removing 'metric selector' and 'streetname.ifnull'
alldata = alldata[,-c(15, 20)]

save(alldata, file = "../../rda_files/all_data.rda")
@


\end{document}